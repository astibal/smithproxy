#pragma once
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <utility>
#include <vector>
#include <array>
#include <deque>
#include <map>
#include <limits>
#include <string>

#include <display.hpp>

// Originally developed here: https://github.com/jnferguson/hpack-rfc7541

//#define DEBUG_VARS

namespace HPACK
{
    using header_t = std::pair<const std::string, const std::string>;
    using bits_t = std::vector<bool>;

    static const std::array< header_t, 62 > predefined_headers = {
            {
                    header_t("INVALIDINDEX", "INVALIDINDEX"),
                    header_t(":authority", ""),
                    header_t(":method", "GET"),
                    header_t(":method", "POST"),
                    header_t(":path", "/"),
                    header_t(":path", "/index.html"),
                    header_t(":scheme", "http"),
                    header_t(":scheme", "https"),
                    header_t(":status", "200"),
                    header_t(":status", "204"),
                    header_t(":status", "206"),
                    header_t(":status", "304"),
                    header_t(":status", "400"),
                    header_t(":status", "404"),
                    header_t(":status", "500"),
                    header_t("accept-charset", ""),
                    header_t("accept-encoding", "gzip, deflate"),
                    header_t("accept-language", ""),
                    header_t("accept-ranges", ""),
                    header_t("accept", ""),
                    header_t("access-control-allow-origin", ""),
                    header_t("age", ""),
                    header_t("allow", ""),
                    header_t("authorization", ""),
                    header_t("cache-control", ""),
                    header_t("content-disposition", ""),
                    header_t("content-encoding", ""),
                    header_t("content-language", ""),
                    header_t("content-length", ""),
                    header_t("content-location", ""),
                    header_t("content-range", ""),
                    header_t("content-type", ""),
                    header_t("cookie", ""),
                    header_t("date", ""),
                    header_t("etag", ""),
                    header_t("expect", ""),
                    header_t("expires", ""),
                    header_t("from", ""),
                    header_t("host", ""),
                    header_t("if-match", ""),
                    header_t("if-modified-since", ""),
                    header_t("if-none-match", ""),
                    header_t("if-range", ""),
                    header_t("if-unmodified-since", ""),
                    header_t("last-modified", ""),
                    header_t("link", ""),
                    header_t("location", ""),
                    header_t("max-forwards", ""),
                    header_t("proxy-authenticate", ""),
                    header_t("proxy-authorization", ""),
                    header_t("range", ""),
                    header_t("referer", ""),
                    header_t("refresh", ""),
                    header_t("retry-after", ""),
                    header_t("server", ""),
                    header_t("set-cookie", ""),
                    header_t("strict-transport-security", ""),
                    header_t("transfer-encoding", ""),
                    header_t("user-agent", ""),
                    header_t("vary", ""),
                    header_t("via", ""),
                    header_t("www-authenticate", "")
            }
    };

    // 256 chars plus end of string
    static const std::array< bits_t, 257 > huffman_table = {
    {
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 0, 0, 0 },                                                             //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 1, 1, 0, 0, 0 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  0, 0, 1, 0 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  0, 0, 1, 1 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  0, 1, 0, 0 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  0, 1, 0, 1 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  0, 1, 1, 0 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  0, 1, 1, 1 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  1, 0, 0, 0 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 0, 1, 0, 1, 0 },                           //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 0, 0 },        //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  1, 0, 0, 1 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  1, 0, 1, 0 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 0, 1 },        //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  1, 0, 1, 1 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  1, 1, 0, 0 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  1, 1, 0, 1 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  1, 1, 1, 0 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  1, 1, 1, 1 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 0, 0, 0 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 0, 0, 1 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 0, 1, 0 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 0 },        //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 0, 1, 1 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 0, 0 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 0, 1 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 1, 0 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 1, 1 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 0, 0 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 0, 1 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 1, 0 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 1, 1 },              //
        { 0, 1, 0, 1, 0, 0 },                                                                                   //   ' '
        { 1, 1, 1, 1, 1, 1, 1, 0,  0, 0 },                                                                      //   '!'
        { 1, 1, 1, 1, 1, 1, 1, 0,  0, 1 },                                                                      //   '"'
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 1, 0 },                                                                //   '#'
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 0, 0, 1 },                                                             //   '$'
        { 0, 1, 0, 1, 0, 1 },                                                                                   //   '%'
        { 1, 1, 1, 1, 1, 0, 0, 0 },                                                                             //   '&'
        { 1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 0 },                                                                   //   '''
        { 1, 1, 1, 1, 1, 1, 1, 0,  1, 0 },                                                                      //   '('
        { 1, 1, 1, 1, 1, 1, 1, 0,  1, 1 },                                                                      //   ')'
        { 1, 1, 1, 1, 1, 0, 0, 1 },                                                                             //   '*'
        { 1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 1 },                                                                   //   '+'
        { 1, 1, 1, 1, 1, 0, 1, 0 },                                                                             //   ','
        { 0, 1, 0, 1, 1, 0 },                                                                                   //   '-'
        { 0, 1, 0, 1, 1, 1 },                                                                                   //   '.'
        { 0, 1, 1, 0, 0, 0 },                                                                                   //   '/'
        { 0, 0, 0, 0, 0 },                                                                                      //   '0'
        { 0, 0, 0, 0, 1 },                                                                                      //   '1'
        { 0, 0, 0, 1, 0 },                                                                                      //   '2'
        { 0, 1, 1, 0, 0, 1 },                                                                                   //   '3'
        { 0, 1, 1, 0, 1, 0 },                                                                                   //   '4'
        { 0, 1, 1, 0, 1, 1 },                                                                                   //   '5'
        { 0, 1, 1, 1, 0, 0 },                                                                                   //   '6'
        { 0, 1, 1, 1, 0, 1 },                                                                                   //   '7'
        { 0, 1, 1, 1, 1, 0 },                                                                                   //   '8'
        { 0, 1, 1, 1, 1, 1 },                                                                                   //   '9'
        { 1, 0, 1, 1, 1, 0, 0 },                                                                                //   ':'
        { 1, 1, 1, 1, 1, 0, 1, 1 },                                                                             //   ';'
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 0, 0 },                                                       //   '<'
        { 1, 0, 0, 0, 0, 0 },                                                                                   //   '='
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 1, 1 },                                                                //   '>'
        { 1, 1, 1, 1, 1, 1, 1, 1,  0, 0 },                                                                      //   '?'
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 0, 1, 0 },                                                             //   '@'
        { 1, 0, 0, 0, 0, 1 },                                                                                   //   'A'
        { 1, 0, 1, 1, 1, 0, 1 },                                                                                //   'B'
        { 1, 0, 1, 1, 1, 1, 0 },                                                                                //   'C'
        { 1, 0, 1, 1, 1, 1, 1 },                                                                                //   'D'
        { 1, 1, 0, 0, 0, 0, 0 },                                                                                //   'E'
        { 1, 1, 0, 0, 0, 0, 1 },                                                                                //   'F'
        { 1, 1, 0, 0, 0, 1, 0 },                                                                                //   'G'
        { 1, 1, 0, 0, 0, 1, 1 },                                                                                //   'H'
        { 1, 1, 0, 0, 1, 0, 0 },                                                                                //   'I'
        { 1, 1, 0, 0, 1, 0, 1 },                                                                                //   'J'
        { 1, 1, 0, 0, 1, 1, 0 },                                                                                //   'K'
        { 1, 1, 0, 0, 1, 1, 1 },                                                                                //   'L'
        { 1, 1, 0, 1, 0, 0, 0 },                                                                                //   'M'
        { 1, 1, 0, 1, 0, 0, 1 },                                                                                //   'N'
        { 1, 1, 0, 1, 0, 1, 0 },                                                                                //   'O'
        { 1, 1, 0, 1, 0, 1, 1 },                                                                                //   'P'
        { 1, 1, 0, 1, 1, 0, 0 },                                                                                //   'Q'
        { 1, 1, 0, 1, 1, 0, 1 },                                                                                //   'R'
        { 1, 1, 0, 1, 1, 1, 0 },                                                                                //   'S'
        { 1, 1, 0, 1, 1, 1, 1 },                                                                                //   'T'
        { 1, 1, 1, 0, 0, 0, 0 },                                                                                //   'U'
        { 1, 1, 1, 0, 0, 0, 1 },                                                                                //   'V'
        { 1, 1, 1, 0, 0, 1, 0 },                                                                                //   'W'
        { 1, 1, 1, 1, 1, 1, 0, 0 },                                                                             //   'X'
        { 1, 1, 1, 0, 0, 1, 1 },                                                                                //   'Y'
        { 1, 1, 1, 1, 1, 1, 0, 1 },                                                                             //   'Z'
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 0, 1, 1 },                                                             //   '['
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  0, 0, 0 },                                          //   '\'
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 0, 0 },                                                             //   ']'
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 0, 0 },                                                          //   '^'
        { 1, 0, 0, 0, 1, 0 },                                                                                   //   '_'
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 0, 1 },                                                       //   '`'
        { 0, 0, 0, 1, 1 },                                                                                      //   'a'
        { 1, 0, 0, 0, 1, 1 },                                                                                   //   'b'
        { 0, 0, 1, 0, 0 },                                                                                      //   'c'
        { 1, 0, 0, 1, 0, 0 },                                                                                   //   'd'
        { 0, 0, 1, 0, 1 },                                                                                      //   'e'
        { 1, 0, 0, 1, 0, 1 },                                                                                   //   'f'
        { 1, 0, 0, 1, 1, 0 },                                                                                   //   'g'
        { 1, 0, 0, 1, 1, 1 },                                                                                   //   'h'
        { 0, 0, 1, 1, 0 },                                                                                      //   'i'
        { 1, 1, 1, 0, 1, 0, 0 },                                                                                //   'j'
        { 1, 1, 1, 0, 1, 0, 1 },                                                                                //   'k'
        { 1, 0, 1, 0, 0, 0 },                                                                                   //   'l'
        { 1, 0, 1, 0, 0, 1 },                                                                                   //   'm'
        { 1, 0, 1, 0, 1, 0 },                                                                                   //   'n'
        { 0, 0, 1, 1, 1 },                                                                                      //   'o'
        { 1, 0, 1, 0, 1, 1 },                                                                                   //   'p'
        { 1, 1, 1, 0, 1, 1, 0 },                                                                                //   'q'
        { 1, 0, 1, 1, 0, 0 },                                                                                   //   'r'
        { 0, 1, 0, 0, 0 },                                                                                      //   's'
        { 0, 1, 0, 0, 1 },                                                                                      //   't'
        { 1, 0, 1, 1, 0, 1 },                                                                                   //   'u'
        { 1, 1, 1, 0, 1, 1, 1 },                                                                                //   'v'
        { 1, 1, 1, 1, 0, 0, 0 },                                                                                //   'w'
        { 1, 1, 1, 1, 0, 0, 1 },                                                                                //   'x'
        { 1, 1, 1, 1, 0, 1, 0 },                                                                                //   'y'
        { 1, 1, 1, 1, 0, 1, 1 },                                                                                //   'z'
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 0 },                                                       //   '{'
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 0 },                                                                   //   '|'
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 0, 1 },                                                          //   '}'
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 0, 1 },                                                             //   '~'
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 0, 0 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  0, 1, 1, 0 },                                       //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 0, 0, 1, 0 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  0, 1, 1, 1 },                                       //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  1, 0, 0, 0 },                                       //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 0, 0, 1, 1 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 0, 1, 0, 0 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 0, 1, 0, 1 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 1, 1, 0, 0, 1 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 0, 1, 1, 0 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 1, 1, 0, 1, 0 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 1, 1, 0, 1, 1 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 1, 1, 1, 0, 0 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 1, 1, 1, 0, 1 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 1, 1, 1, 1, 0 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 0, 1, 0, 1, 1 },                           //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 1, 1, 1, 1, 1 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 0, 1, 1, 0, 0 },                           //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 0, 1, 1, 0, 1 },                           //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 0, 1, 1, 1 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 0, 0, 0, 0, 0 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 0, 1, 1, 1, 0 },                           //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 0, 0, 0, 0, 1 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 0, 0, 0, 1, 0 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 0, 0, 0, 1, 1 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 0, 0, 1, 0, 0 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  1, 1, 1, 0, 0 },                                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 1, 0, 0, 0 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 0, 0, 1, 0, 1 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 1, 0, 0, 1 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 0, 0, 1, 1, 0 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 0, 0, 1, 1, 1 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 0, 1, 1, 1, 1 },                           //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 1, 0, 1, 0 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  1, 1, 1, 0, 1 },                                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  1, 0, 0, 1 },                                       //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 1, 0, 1, 1 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 1, 1, 0, 0 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 0, 1, 0, 0, 0 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 0, 1, 0, 0, 1 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  1, 1, 1, 1, 0 },                                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 0, 1, 0, 1, 0 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 1, 1, 0, 1 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 1, 1, 1, 0 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 0, 0, 0, 0 },                           //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  1, 1, 1, 1, 1 },                                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 1, 1, 1, 1 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 0, 1, 0, 1, 1 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 0, 1, 1, 0, 0 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 0, 0, 0, 0 },                                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 0, 0, 0, 1 },                                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 0, 0, 0, 0 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 0, 0, 1, 0 },                                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 0, 1, 1, 0, 1 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 0, 0, 0, 1 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 0, 1, 1, 1, 0 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 0, 1, 1, 1, 1 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  1, 0, 1, 0 },                                       //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 0, 0, 1, 0 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 0, 0, 1, 1 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 0, 1, 0, 0 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 0, 0, 0, 0 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 0, 1, 0, 1 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 0, 1, 1, 0 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 0, 0, 0, 1 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 0, 0, 0,  0, 0 },                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 0, 0, 0,  0, 1 },                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  1, 0, 1, 1 },                                       //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  0, 0, 1 },                                          //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 0, 1, 1, 1 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 0, 0, 1, 0 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 1, 0, 0, 0 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 0, 1, 1, 0,  0 },                       //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 0, 0, 0,  1, 0 },                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 0, 0, 0,  1, 1 },                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 0, 0, 1,  0, 0 },                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 0, 1, 1,  1, 1, 0 },                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 0, 1, 1,  1, 1, 1 },                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 0, 0, 1,  0, 1 },                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 0, 0, 0, 1 },                           //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 0, 1, 1, 0,  1 },                       //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  0, 1, 0 },                                          //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 0, 0, 1, 1 },                                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 0, 0, 1,  1, 0 },                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 0, 0,  0, 0, 0 },                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 0, 0,  0, 0, 1 },                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 0, 0, 1,  1, 1 },                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 0, 0,  0, 1, 0 },                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 0, 0, 1, 0 },                           //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 0, 1, 0, 0 },                                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 0, 1, 0, 1 },                                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 0, 1, 0,  0, 0 },                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 0, 1, 0,  0, 1 },                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 0, 1 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 0, 0,  0, 1, 1 },                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 0, 0,  1, 0, 0 },                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 0, 0,  1, 0, 1 },                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  1, 1, 0, 0 },                                       //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 0, 0, 1, 1 },                           //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  1, 1, 0, 1 },                                       //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 0, 1, 1, 0 },                                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 1, 0, 0, 1 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 0, 1, 1, 1 },                                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 0, 0, 0 },                                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 0, 0, 1, 1 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 1, 0, 1, 0 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 0, 1, 0, 1, 1 },                                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 0, 1, 1, 1,  0 },                       //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 0, 1, 1, 1,  1 },                       //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 0, 1, 0, 0 },                           //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 0, 1, 0, 1 },                           //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 0, 1, 0,  1, 0 },                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 0, 1, 0, 0 },                              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 0, 1, 0,  1, 1 },                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 0, 0,  1, 1, 0 },                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 0, 1, 1,  0, 0 },                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 0, 1, 1,  0, 1 },                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 0, 0,  1, 1, 1 },                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 0, 1,  0, 0, 0 },                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 0, 1,  0, 0, 1 },                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 0, 1,  0, 1, 0 },                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 0, 1,  0, 1, 1 },                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 0 },              //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 0, 1,  1, 0, 0 },                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 0, 1,  1, 0, 1 },                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 0, 1,  1, 1, 0 },                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 0, 1,  1, 1, 1 },                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 0,  0, 0, 0 },                 //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 0, 1, 1,  1, 0 },                    //
        { 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1 }         //   EOS

        }
    };

    class huffman_node_t
    {

        huffman_node_t*	m_left;
        huffman_node_t* m_right;
        int16_t		m_code;
    public:
        explicit huffman_node_t(huffman_node_t* l = nullptr, huffman_node_t* r = nullptr, int16_t c = -1) : m_left(l), m_right(r), m_code(c) { }
        ~huffman_node_t() { m_left = nullptr; m_right = nullptr; m_code = 0; }
        int16_t code() const noexcept { return m_code; }

        void code(int16_t c) { m_code = c; }

        huffman_node_t* left() noexcept { return m_left; }
        huffman_node_t* right() noexcept { return m_right; }

        void left(huffman_node_t* l) { m_left = l; }
        void right(huffman_node_t* r) { m_right = r; }
    };

    class hpack_error : public std::runtime_error {
    public:
        explicit hpack_error(const char* e) : std::runtime_error(e) {};
    };

    class huffman_tree_t
    {
        huffman_node_t* m_root;

        void delete_node( huffman_node_t* n ) {

            if(not n) return;

            if ( nullptr != n->right())
                delete_node(n->right());

            if ( nullptr != n->left())
                delete_node(n->left());

            delete n;
        }

    public:
        huffman_tree_t() : m_root(new huffman_node_t)
        {
            for ( std::size_t idx = 0; idx < huffman_table.size(); idx++ ) {
                const bits_t&		bits = huffman_table.at(idx);
                huffman_node_t*		current = m_root;

                for ( const auto& bit : bits ) {
                    if ( true == bit ) {
                        if ( nullptr == current->right() )
                            current->right(new huffman_node_t);

                        current = current->right();
                    } else {
                        if ( nullptr == current->left() )
                            current->left(new huffman_node_t);

                        current = current->left();
                    }
                }

                current->code(static_cast< int16_t >( idx ));
            }
        }
        ~huffman_tree_t()  {
            delete_node(m_root);
        }


        std::string decode(std::string const& src)
        {
            std::stringstream	dst;
            huffman_node_t*		current(m_root);

            if ( src.length() > std::numeric_limits< unsigned int >::max() )
                throw std::invalid_argument("HPACK::huffman_tree_t::decode(): Overly long input string");

            for ( unsigned int idx = 0; idx < src.size(); idx++ ) {
                for ( int8_t j = 7; j >= 0; j-- ) {
                    if ( ( src[ idx ] & ( 1 << j ) ) != 0 ) {
                        if ( nullptr == current->right() )
                            throw hpack_error("HPACK::huffman_tree_t::decode(): Internal state error (right == nullptr)");
                        current = current->right();
                    } else {
                        if ( nullptr == current->left() )
                            throw hpack_error("HPACK::huffman_tree_t::decode(): Internal state error (left == nullptr)");

                        current = current->left();
                    }

                    if ( current->code() >= 0 ) {
                        uint16_t code = current->code();

                        if ( 257 == code )
                            dst << static_cast< uint8_t >( ( ( code & 0xFF00u ) >> 8u ) & 0xFF );

                        dst << static_cast< uint8_t >( code & 0xFFu );
                        current = m_root;
                    }
                }
            }

            return dst.str();
        }
    };

    class ringtable_t
    {
        uint64_t				m_max;
        std::deque< header_t >	m_queue;

    public:
        // 4096 is the default table size per the HTTPv2 RFC
        ringtable_t() : m_max(4096) {}
        explicit ringtable_t(uint64_t m) : m_max(m) {}
        virtual ~ringtable_t() = default;

        void
        max(uint64_t m)
        {
            m_max = m;

            // the RFC dictates that we do this here,
            // so we do.

            if(m == 0) {
                m_queue.clear();
            }
            else {
                while (length() >= m_max) {
                    m_queue.pop_back();
                }
            }
        }

        [[nodiscard]] inline uint64_t max() const noexcept { return m_max; }

        [[nodiscard]] inline uint64_t entries_count() const { return m_queue.size(); }

        [[nodiscard]] inline uint64_t length() const {

            uint64_t size = 0L;

            for ( auto& h : m_queue ) {
                uint64_t nl(h.first.length());
                uint64_t vl(h.second.length());
                uint64_t tl(0);

                // In practice it should basically never occur
                // that either of these exceptions are thrown and
                // its probably safe to remove the checks in most instances
                if ( vl > std::numeric_limits< uint64_t >::max() ||
                     nl > std::numeric_limits< uint64_t >::max() - vl )
                    throw std::runtime_error("HPACK::ringtable_t::length() Additive integer overflow encountered");

                tl = nl + vl;

                if ( tl > std::numeric_limits< uint64_t >::max() - size )
                    throw std::runtime_error("HPACK::ringtable_t::length() Additive integer overflow encountered");

                size += tl;

            }

            return size;
        }

        void add(const header_t&  h) {

            // In practice, it should be basically implausible to trip these exceptions because
            // you would need 2^(sizeof(uint64_t)*8) bytes of memory to be in use, which in itself
            // will likely fail long before then. In other words its probably safe to remove
            // these checks for the foreseeable future, but I left them in because technically I
            // should check even if it's an absurd condition.

            if ( h.first.length() > std::numeric_limits< uint64_t >::max() - h.second.length() )
                throw std::runtime_error("HPACK::ringtable_t::add(): Additive integer overflow encountered.");

            // Again the RFC dictates when we resize the queue.

            if(m_max == 0) {
                m_queue.clear();
            } else {
                while (length() >= m_max) {
                    m_queue.pop_back();
                }
            }

            m_queue.push_front(h);
        }

        void add(const std::string& n, const std::string& v) {

            header_t h(n, v);

            add(h);
        }

        void add(const char* n, const char* v) {

            std::string name(n);
            std::string value(v);

            if ( nullptr == n || nullptr == v )
                throw std::runtime_error("HPACK::ringtable_t::add(): Invalid nullptr parameter(s)");

            add(name, value);
        }

        header_t const& at(uint64_t idx) {

            if ( idx > m_queue.size() ) {
                // It's not clear these checks even entirely make sense
                // the concern was that someone passes in an out-of-bounds
                // index, but that's because the static and dynamic
                // tables have their indices flattened into one, so we
                // attempt to address that by subtracting the static
                // headers index size if we are out of bounds, which
                // might yield a totally bogus index due to implementation
                // bug asking for an invalid index that just happens to line
                // up.
                if ( idx < predefined_headers.size() )
                    throw std::invalid_argument("HPACK::ringtable_t::at(): Invalid/out-of-bounds index specified");

                idx -= predefined_headers.size();

                if ( idx > m_queue.size() )
                    throw std::invalid_argument("HPACK::ringtable_t::at(): Invalid/out-of-bounds index specified");

            }

            return m_queue.at(static_cast< std::size_t >( idx ));
        }

        bool find(header_t const& h, int64_t& index) const {


            if ( static_cast<std::size_t>(index) > std::numeric_limits< std::size_t >::max() ) {
                throw std::invalid_argument("HPACK::ringtable_t::find(): Invalid/overlarge index which results in truncation");
            }

            index = -1;

            for ( std::size_t idx = 0; idx < m_queue.size(); idx++ ) {
                if ( h.first == m_queue.at(idx).first and h.second == m_queue.at(idx).second ) {
                    index = predefined_headers.size() + idx;
                    return true;
                } else if ( h.first == m_queue.at(idx).first ) {
                    index = predefined_headers.size() + idx;
                    return false;
                }
            }

            return false;
        }

        header_t const* get_header(const std::size_t index) const {

            if ( index < predefined_headers.size() ) {
                return &predefined_headers.at(index);
            } else if ( index < predefined_headers.size() + m_queue.size() )
                return &m_queue.at(index - predefined_headers.size());

            return nullptr;
        }

    };

    class huffman_encoder_t
    {
    private:
        uint8_t m_byte;
        uint8_t m_count;

    protected:
        inline bool
        write_bit(uint8_t bit)
        {
            m_byte |= bit;
            m_count--;

            if (0 == m_count ) {
                m_count = 8;
                return true;
            } else
                m_byte <<= 1;

            return false;
        }

    public:
        huffman_encoder_t() : m_byte(0), m_count(8) { }

        std::vector< uint8_t >
        encode(std::vector< uint8_t >& src)
        {
            std::vector< uint8_t > ret(0);

            for ( auto const& byte : src ) {
                bits_t bits = huffman_table.at(byte);

                for ( auto const& bit : bits ) {
                    if ( true == write_bit(bit) ) {
                        ret.push_back(m_byte);
                        m_byte = 0;
                        m_count = 8;
                    }

                }
            }

            // Apparently the remainder unused bits
            // are to be set to 1, some sources refer
            // to this as the EOS bit, but the code
            // for EOS is like 30-bits of 1's, so It's
            // clearly not the EOS code.
            if ( 8 != m_count && 0 != m_count) {
                m_byte = ( m_byte << ( m_count - 1 ) );
                m_byte |= ( 0xFF >> ( 8 - m_count ) );
                ret.push_back(m_byte);
                m_byte = 0;
                m_count = 8;
            }

            return ret;
        }

        std::vector< uint8_t >
        encode(const std::string& src)
        {
            std::vector< uint8_t > s(src.begin(), src.end());
            return encode(s);
        }

        std::vector< uint8_t >
        encode(const char* ptr)
        {
            std::string str(ptr);

            if ( nullptr == ptr )
                throw std::invalid_argument("HPACK::huffman_encoder_t::encode(): Invalid nullptr parameter");

            return encode(str);
        }
    };

    /*! \Class The HPACK decoder class.
     *  \Brief A wrapper class that ties together the static, dynamic tables and huffman
     *  encoding such that one can pass in a HTTPv2 header block and retrieve a map of strings
     *  that container the headers sent.
     *
     * \Warning Never Indexed code paths under tested.
     */
    class decoder_t
    {
        using header_map_type = std::map< std::string, std::vector<std::string>, std::less<>>;
        using dec_vec_itr_t = std::vector< uint8_t >::iterator;

        header_map_type	m_headers;
        ringtable_t		m_dynamic;
        huffman_tree_t	m_huffman;


    public:

        void decode_integer(dec_vec_itr_t& beg, dec_vec_itr_t& end, uint32_t& dst, uint8_t N) {
            dec_vec_itr_t&  current(beg);

            auto mask = (1 << N) - 1;

            auto I = *current & mask;

            if(I < std::pow(2,N)-1 ) {
                dst=I;
                beg++;
                return;
            }

            uint8_t  M = 0;
            uint8_t B = 0;
            do {
                B = *(++current);
                I += ((B & 0x7F) * std::pow(2, M));
                M += 7;

            } while( ( B & 0x80 ) == 0x80);

            dst = I;
            beg = current + 1;
        }

        std::string parse_string(dec_vec_itr_t& itr, dec_vec_itr_t& end) {

            unsigned int	len = 0;
            bool			huff(( *itr & 0x80 ) == 0x80 ? true : false);

            decode_integer(itr, end, len, 7);

#ifdef DEBUG_VARS
            std::string deb1(itr, itr+len);
            std::string deb2 = hex_print(deb1.data(), deb1.size());
#endif
            if ( itr >= end )
                throw std::invalid_argument("HPACK::decoder_t::parse_string(): Attempted to parse string when already at end of input");

            std::string dst(itr, itr+len);
            itr += len;


            if ( true == huff )
                dst = m_huffman.decode(dst);

            return dst;
        }

        /*!
            \fn encoder_t(uint64_t max = 4096)
            \Brief Constructs the encoder

            \param max the maximum size of the dynamic table; unbounded and allowed to exceed RFC sizes
        */
        decoder_t(int64_t max = 4096) : m_dynamic(max) { }


        /*!
            \fn bool decode(const std::string&)
            \Brief Decodes the HTTPv2 Header Block contained within the parameter

            \param str the HTTPv2 Header Block
            \return True if decoding was successful, false if an error such as a protocol decoding error was encountered.

            \Warning Never indexed code paths were under tested.
        */
        bool decode(const std::string& str) {

            auto vec = std::vector< uint8_t >(str.begin(), str.end());
            return decode(vec);
        }

        /*!
            \fn bool decode(const std::string&)
            \Brief Decodes the HTTPv2 Header Block contained within the parameter

            \param ptr the HTTPv2 Header Block
            \return True if decoding was successful, false if an error such as a protocol decoding error was encountered.

            \Warning Never indexed code paths were under tested.
        */
        bool decode(const char* ptr) {

            if ( nullptr == ptr )
                throw std::invalid_argument("HPACK::decoder_t::decode(): Invalid nullptr parameter");

            return decode(std::string(ptr));
        }


        /*!
            \fn bool decode(const std::string&)
            \Brief Decodes the HTTPv2 Header Block contained within the parameter

            \param data the HTTPv2 Header Block
            \return True if decoding was successful, false if an error such as a protocol decoding error was encountered.

            \Warning Never indexed code paths were under tested.
        */
        bool decode(std::vector< uint8_t >& data) {


            if ( data.empty() )
                return false;

            auto itr = data.begin();
            auto end = data.end();



            for(size_t loop = 0; end - itr > 0 and loop < 100; ++loop) {

                auto byte_value = *itr;

                if ( 0x20 == ( byte_value & 0xE0 ) ) { // 6.3 Dynamic Table update
                    uint32_t size(0);

                    decode_integer(itr, end, size, 5);

                    if ( size > m_dynamic.max() ) {
                        // decoding error

                        // report error - dynamic update too big
                    }

                    m_dynamic.max(size);
                } else if ( ( byte_value & 0x80 ) ) { // 6.1 Indexed Header Field Representation
                    uint32_t index(0);

                    decode_integer(itr, end, index, 7);

                    if ( 0 == index ) {
                        // decoding error

                        // report index zero error
                        return false;
                    }

                    auto const* hdr_ptr = m_dynamic.get_header(index);
                    if(hdr_ptr) {
                        m_headers[hdr_ptr->first].emplace_back(hdr_ptr->second);
                    } else {
                        // report error - index not found
                    }
                } else if(end - itr > 0){

                    uint32_t index(0);
                    std::string n;

                    if ( 0x40 == ( byte_value & 0xC0 ) ) // 6.2.1 Literal Header Field with Incremental Indexing
                        decode_integer(itr, end, index, 6);
                    else // 6.2.2 Literal Header Field without Indexing
                        decode_integer(itr, end, index, 4);

                    if ( 0 != index ) {
                        auto const* h = m_dynamic.get_header(index);
                        if(h) {
                            n = h->first;
                        } else {
                            //report index error
                        }
                    } else {
                        n = parse_string(itr, end);
                    }

                    auto val = parse_string(itr, end);
                    m_headers[ n ].emplace_back(val);
                } else {
                    break;
                }
            }

            return true;
        }


        /*!
            \fn const std::map< std::string, std::string >& headers(void) const
            \Brief Retrieves the internally managed header map of decoded headers

            \Return The map of the decoded headers
         */
        [[nodiscard]] header_map_type const& headers() const
        {
            return m_headers;
        }
    };


    /*! \Class The HPACK encoder class.
     *  \Brief A wrapper class that ties together the ringtable_t dynamic table implementation
     * with the prior static table such that one can simply add(name, value) into an
     * internally managed buffer (a std::vector< uint8_t >) which can be retrieved at
     * the end of operations. Huffman encoding and dynamic table references are handled
     * automatically;
     *
     * \Warning Never Indexed code paths untested.
     */
    class encoder_t
    {
    public:

        constexpr static uint8_t HUFFMAN_ENCODED = 0x80;
        constexpr static uint8_t LITERAL_WITHOUT_INDEXING_BIT_PATTERN = 0x00;
        constexpr static uint8_t LITERAL_NEVER_INDEXED_BIT_PATTERN = 0x10;
        constexpr static uint8_t  LITERAL_INDEXED_BIT_PATTERN = 0x40;
        constexpr static uint8_t  INDEXED_BIT_PATTERN = 0x80;

    private:
        std::vector< uint8_t >	m_buf;
        ringtable_t				m_dynamic;
        huffman_encoder_t		m_huffman;

        void
        huff_encode(const std::string& str)
        {
            std::vector< uint8_t >	huffbuff(0);

            huffbuff = m_huffman.encode(str);

            if ( 128 > huffbuff.size() )
                m_buf.push_back(static_cast< uint8_t >( HUFFMAN_ENCODED | huffbuff.size() ));
            else {
                std::vector< uint8_t > tmp;
                encode_integer(tmp, huffbuff.size(), 7);
                tmp.front() |= HUFFMAN_ENCODED;
                m_buf.insert(m_buf.end(), tmp.begin(), tmp.end());
            }

            m_buf.insert(m_buf.end(), huffbuff.begin(), huffbuff.end());
        }

        bool find(const header_t& h, int64_t& index) {

            int64_t saved_index(-1);
            index = -1;

            for ( uint64_t idx = 1; idx < predefined_headers.size(); idx++ ) {
                if ( h.first == predefined_headers.at(static_cast< std::size_t >( idx )).first and
                     h.second == predefined_headers.at(static_cast< std::size_t >( idx )).second ) {
                    index = idx;
                    return true;
                } else if ( h.first == predefined_headers.at(static_cast< std::size_t >( idx )).first) {
                    index = idx;
                }
            }

            saved_index = index;

            if ( true == m_dynamic.find(h, index) )
                return true;
            else if ( -1 != index )
                return false;

            if ( -1 != saved_index )
                index = saved_index;

            return false;
        }

        uint64_t encode_integer(std::vector< uint8_t >& dst, uint32_t I, uint8_t N) const {

            const auto two_N = static_cast< uint16_t >( std::pow(2, N) - 1 );

            if ( I < two_N ) {
                dst.push_back(static_cast< uint8_t >( I ));
                return 1;
            } else {
                I -= two_N;
                dst.push_back(static_cast< uint8_t >( two_N ));

                while ( I >= 128 ) {
                    dst.push_back(static_cast< uint8_t >( ( I & 0x7F ) | 0x80 ));
                    I >>= 7;
                }

                dst.push_back(static_cast< uint8_t >( I ));
                return dst.size();
            }
        }

    public:
        /*!
        \fn encoder_t(uint64_t max = 4096)
        \Brief Constructs the encoder

        \param max the maximum size of the dynamic table; unbounded and allowed to exceed RFC sizes
        */
        explicit encoder_t(uint64_t max = 4096) : m_dynamic(max) {}

        /*!
        \fn void max_table_size(uint64_t max)
        \Brief Resizes the dynamic table

        \param max the maximum size of the dynamic table; unbounded and allowed to exceed RFC sizes
        */
        void max_table_size(uint64_t max) { m_dynamic.max(max); }

        /*!
        \fn inline uint64_t max_table_size(void) const
        \Brief Retrieve the size of dynamic table

        \return max the maximum size of the dynamic table; unbounded and allowed to exceed RFC sizes
        */

        inline uint64_t  max_table_size() const noexcept { return m_dynamic.max(); }

        /*!
        \fn void add(const std::string& n, const std::string& v, bool huffman = true, bool never_indexed = false)
        \Brief Add a header name-value pair to the header list

        \param n the name-value pair name member
        \param v the name-value pair value member
        \param huffman a boolean value that indicates whether to huffman encode any related string literals
        \param never_indexed whether to set the never indexed flag for the name-value pair
        */

        void add(std::string const& n, const std::string& v, bool huffman = true, bool never_indexed = false) {
            header_t h(n, v);
            add(h, huffman, never_indexed);
        }

        /*!
        \fn void add(const char* n, const char* v, bool huffman = true, bool never_indexed = false)
        \Brief Add a header name-value pair to the header list
        \Throws std::invalid_argument() when n or v is null

        \param n the name-value pair name member
        \param v the name-value pair value member
        \param huffman a boolean value that indicates whether to huffman encode any related string literals
        \param never_indexed whether to set the never indexed flag for the name-value pair
        */

        void add(const char* n, const char* v, bool huffman = true, bool never_indexed = false) {
            header_t h(n, v);

            if ( nullptr == n || nullptr == v )
                throw std::invalid_argument("HPACK::encoder_t::add(): Invalid nullptr parameter.");

            add(h, huffman, never_indexed);
        }

        /*!
        \fn void add(const header_t& h, bool huffman = true, bool never_indexed = false)
        \Brief Add a header name-value pair to the header block

        \param h the name-value header_t pair to be added to the header block
        \param huffman a boolean value that indicates whether to huffman encode any related string literals
        \param never_indexed whether to set the never indexed flag for the name-value pair
        */

        void add(header_t const& h, bool huffman = true, bool never_indexed = false) {
            int64_t					index(0);
            std::vector< uint8_t >	buf(0), huffbuff(0);

            if ( false == never_indexed && true == find(h, index) ) {
                encode_integer(buf, static_cast< uint32_t >(index), 7);

                buf.front() |= INDEXED_BIT_PATTERN;
                m_buf.insert(m_buf.end(), buf.begin(), buf.end());
                buf.clear();
            } else if ( false == never_indexed && -1 != index ) {
                m_dynamic.add(h.first, h.second);

                if ( false == never_indexed ) {
                    encode_integer(buf, static_cast< uint32_t >(index), 6);
                    buf.front() |= LITERAL_INDEXED_BIT_PATTERN;
                    m_buf.insert(m_buf.end(), buf.begin(), buf.end());
                    buf.clear();
                } else {
                    encode_integer(buf, static_cast< uint32_t >(index), 4);
                    buf.front() |= LITERAL_NEVER_INDEXED_BIT_PATTERN;
                    m_buf.insert(m_buf.end(), buf.begin(), buf.end());
                    buf.clear();
                }

                if ( true == huffman )
                    huff_encode(h.second);
                else {
                    buf.clear();
                    encode_integer(buf, h.second.length(), 7);
                    m_buf.insert(m_buf.end(), h.second.begin(), h.second.end());
                }
            } else {
                if ( false == never_indexed ) {
                    m_dynamic.add(h.first, h.second);
                    m_buf.push_back(LITERAL_INDEXED_BIT_PATTERN);
                } else
                    m_buf.push_back(LITERAL_NEVER_INDEXED_BIT_PATTERN);

                if ( true == huffman && false == never_indexed )
                    huff_encode(h.first);
                else {
                    buf.clear();
                    encode_integer(buf, h.first.length(), 7);
                    m_buf.insert(m_buf.end(), buf.begin(), buf.end());
                    m_buf.insert(m_buf.end(), h.first.begin(), h.first.end());
                }
                if ( true == huffman && false == never_indexed )
                    huff_encode(h.second);
                else {
                    buf.clear();
                    encode_integer(buf, h.second.length(), 7);
                    m_buf.insert(m_buf.end(), buf.begin(), buf.end());
                    m_buf.insert(m_buf.end(), h.second.begin(), h.second.end());
                }
            }
        }

        std::vector<uint8_t>& data() { return m_buf; }
    };
}
